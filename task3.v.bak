module task3(input [3:0] KEY, input [9:0] SW, output [9:0] LED; output [6:0] HEX0, HEX1, HEX2, HEX3, HEX4, HEX5);
  wire clk = ~KEY[0];
  wire rst_n = ~KEY[1];

  wire [15:0]   ram_r_data, write_data;
  wire [15:0]   ram_w_data = write_data;
  wire [8:0]    ram_addr;
  wire [7:0]    ram_r_addr = ram_addr[7:0];
  wire [7:0]    ram_w_addr = ram_addr[7:0];
  wire          msel, weq, req; // equality comparator outputs
  wire          ram_w_en = msel & weq;
  wire          mtse = msel & req; // tristate enable
  wire [1:0]    mem_cmd;
  wire [8:0]    start_pc;
  wire [4:0]    present_state;

  wire [15:0]   read_data = mtse ? ram_r_data : 16'bz; // tristate driver

  // instantiate ram and cpu 
  cpu CPU(.clk(clk), .rst_n(rst_n), .ram_r_data(ram_r_data), .start_pc(start_pc), 
          .waiting(wait_out), .out(output_out), .N(N_out), .V(V_out), .Z(Z_out), 
          .ram_w_data(ram_w_data), 
          .ram_addr(ram_addr), .ram_w_en(ram_w_en), .state(present_state));
  equalitycomp #(2) ram_write(2'b01, mem_cmd, weq);
  equalitycomp #(2) ram_read(2'b10, mem_cmd, req);
  equalitycomp #(1) ram_none(1'b0, ram_addr[8], msel);
  ram RAM(.clk(clk), .ram_w_en(ram_w_en), .ram_r_addr(ram_addr), .ram_w_addr(ram_addr),
          .ram_w_data(ram_w_data), .ram_r_data(ram_r_data));

  // switch control
  wire [2:0] switch_control;
  equalitycomp #(9) SC(ram_addr, 9'h140, switch_control[0]);
  equalitycomp #(2) SR(`MREAD, mem_cmd, switch_control[1]);
  assign switch_control[2] = &switch_control[1:0];
  assign read_data = switch_control[2] ? {{8{SW[7]}},SW[7:0]} : 16'bz; // tristate driver

  // LED control
  wire [2:0]  LED_control;
  equalitycomp #(9) led_read(ram_addr, 9'h100, LED_control[0]);
  equalitycomp #(2) led_write(2'b01, mem_cmd, LED_control[1]);
  assign LED_control[2] = &LED_control[1:0];
  vDFF #(8) led_enable(clk, LED_control[2], write_data[7:0], LED[7:0]);

  // Add binram_w_datags for LED[9] - LED [9] is on whenever in wait stage
  assign LED[9] = w;

  // sseg modules
  reg [5:0] hex5, hex4, hex3, hex2, hex1, hex0;
  sseg hex_display_five(hex5, HEX5);
  sseg hex_display_four(hex4, HEX4);
  sseg hex_display_three(hex3, HEX3);
  sseg hex_display_two(hex2, HEX2);
  sseg hex_display_one(hex1, HEX1);
  sseg hex_display_zero(hex0, HEX0);

  parameter [5:0] ZERO = 6'b000000;
  parameter [5:0] ONE = 6'b000001;
  parameter [5:0] TWO = 6'b000010;
  parameter [5:0] THREE = 6'b000011;
  parameter [5:0] FOUR = 6'b000100;
  parameter [5:0] FIVE = 6'b000101;
  parameter [5:0] SIX = 6'b000110;
  parameter [5:0] SEVEN = 6'b000111;
  parameter [5:0] EIGHT = 6'b001000;
  parameter [5:0] NINE = 6'b001001;
  parameter [5:0] BLANK = 6'b111111;

  always @(*) begin
  // Add binram_w_datags for HEX display (always block)
    if(SW[9] == 1) begin // If SW9 up, display states on HEX0 - HEX5
      case(present_state)
        5'b00000: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ZERO, ZERO, ZERO}; // wait
        5'b00001: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ZERO, ZERO, ONE}; // decode
        5'b00010: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ZERO, ONE, ZERO}; // loadA
	    5'b00011: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ZERO, ONE, ONE}; // loadB
	    5'b00100: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ONE, ZERO, ZERO}; // movImmediate
        5'b00101: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ONE, ZERO, ONE}; // add
        5'b00110: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ONE, ONE, ZERO}; // cmp
        5'b00111: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ONE, ONE, ONE}; // and
        5'b01000: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ZERO, ZERO, ZERO}; // mvn
        5'b01001: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ZERO, ZERO, ONE}; // register
        5'b01010: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ZERO, ONE, ZERO}; // fetch1
        5'b01011: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ZERO, ONE, ONE}; // fetch2
        5'b01100: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ONE, ZERO, ZERO}; // LDR
        5'b01101: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ONE, ZERO, ONE}; // LDR2
        5'b01110: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ONE, ONE, ZERO}; // LDR3
        5'b01111: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ONE, ONE, ONE, ONE}; // LDR4
        5'b10000: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ZERO, ZERO, ZERO}; // LDR5
        5'b10001: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ZERO, ZERO, ONE}; // LDR6
        5'b10010: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ZERO, ONE, ZERO}; // STR
        5'b10011: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ZERO, ONE, ONE}; // STR2
        5'b10100: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ONE, ZERO, ZERO}; // STR3
        5'b10101: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ONE, ZERO, ONE}; // STR4
        5'b10110: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ONE, ONE, ZERO}; // STR5
        5'b10111: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ZERO, ONE, ONE, ONE}; // STR6
        5'b11000: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ONE, ZERO, ZERO, ZERO}; // readDecode
        5'b11001: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ONE, ONE, ZERO, ZERO, ONE}; // HALT
        default: {hex5, hex4, hex3, hex2, hex1, hex0} = {ZERO, ZERO, ZERO, ZERO, ZERO, ZERO}; 
      endcase
    end
      else begin // If SW9 down, display PC Counter Value on HEX 0 - HEX5
        hex0 = start_pc[3:0];
        hex1 = start_pc[7:4];
        hex2 = {1'b0, 1'b0, 1'b0, start_pc[8]};
        hex3 = ZERO; 
        hex4 = ZERO; 
        hex5 = ZERO;
      end
    end
endmodule: task3

module cpu(input clk, input rst_n, input [15:0] ram_r_data, input [7:0] start_pc, 
            output waiting, output [15:0] out, output N, output V, output Z,
            output [15:0] ram_w_data, 
            output [7:0] ram_addr, output ram_w_en, output [4:0] state);

  // wires 
  wire [15:0] sximm5, sximm8;
  wire [2:0] opcode, r_addr, w_addr;
  wire [1:0] shift_op, ALU_op;

  wire [1:0] wb_sel, reg_sel;
  wire en_A, en_B, sel_A, sel_B, en_C, en_status, w_en;
  wire load_ir; 

  wire [7:0] PC;

  // assign outputs to regs
  reg wait_out, N_out, V_out, Z_out;
  reg [15:0] instruction_wire, output_out;
  
  
  assign waiting = wait_out;
  assign N = N_out;
  assign V = V_out;
  assign Z = Z_out;
  assign out = output_out;
  assign ram_w_data = output_out;
  
  // program counter 
  wire clear_pc, load_pc, sel_addr, load_addr;
  wire [7:0] data_address; 
  wire [7:0] incrementPC = PC + 1'b1; 
  wire [7:0] next_pc = clear_pc ? start_pc : incrementPC; 
  assign ram_addr = sel_addr ? PC : data_address;
  

  vDFF #(16) INSTRUCTION(.clk(clk), .en(load_ir), .in(ram_r_data), .out(instruction_wire));
  
  // new registers (DFFs)
  vDFF #(8) PCREG(.clk(clk), .en(load_pc), .in(next_pc), .out(PC));
  vDFF #(8) DATA_ADDR_REG(.clk(clk), .en(load_addr), .in(output_out[7:0]), .out(data_address));
  
  idecoder DECODER(.ir(instruction_wire), .reg_sel(reg_sel), 
                .opcode(opcode), .ALU_op(ALU_op), .shift_op(shift_op), 
                .sximm5(sximm5), .sximm8(sximm8), 
                .r_addr(r_addr), .w_addr(w_addr));

  controller FSM(.clk(clk), .rst_n(rst_n),  
                .opcode(opcode), .ALU_op(ALU_op), .shift_op(shift_op), 
                .waiting(wait_out), 
                .reg_sel(reg_sel), .wb_sel(wb_sel), .w_en(w_en), 
                .en_A(en_A), .en_B(en_B), .en_C(en_C), .en_status(en_status), 
                .sel_A(sel_A), .sel_B(sel_B),
                .ram_w_en(ram_w_en), .load_ir(load_ir),
                .load_pc(load_pc), .load_addr(load_addr), 
                .sel_addr(sel_addr), .clear_pc(clear_pc), .present_state(state));

  datapath DATAPATH(.clk(clk), .mdata(ram_r_data), .pc(PC), .wb_sel(wb_sel), 
                .w_addr(w_addr), .w_en(w_en), .r_addr(r_addr), .en_A(en_A), 
                .en_B(en_B), .shift_op(shift_op), .sel_A(sel_A), .sel_B(sel_B), 
                .ALU_op(ALU_op), .en_C(en_C), .en_status(en_status), 
                .sximm8(sximm8), .sximm5(sximm5), 
                .datapath_out(output_out), .Z_out(Z_out), .N_out(N_out), .V_out(V_out));
endmodule: cpu

module controller(input clk, input rst_n, 
                  input [2:0] opcode, input [1:0] ALU_op, input [1:0] shift_op,
                  output waiting,
                  output [1:0] reg_sel, output [1:0] wb_sel, output w_en,
                  output en_A, output en_B, output en_C, output en_status,
                  output sel_A, output sel_B,
                  output ram_w_en, output load_ir,
                  output load_pc, output load_addr, output sel_addr,
                  output clear_pc, output reg [4:0] present_state);

  // define states 
  `define wait 5'b00000 
  `define decode 5'b00001
  `define loadA 5'b00010
  `define loadB 5'b00011
  `define movImmediate 5'b00100
  `define add 5'b00101
  `define cmp 5'b00110
  `define and 5'b00111
  `define mvn 5'b01000
  `define register 5'b01001
  // new states for lab 7
  `define fetch1 5'b01010 // selects addr
  `define fetch2 5'b01011 // loads instr
  `define LDR 5'b01100 // ldr to a
  `define LDR2 5'b01101 // add sximm5
  `define LDR3 5'b01110 // load to data address dff
  `define LDR4 5'b01111 // read from ram
  `define LDR5 5'b10000 // store to Rd
  `define LDR6 5'b10001 // new load
  `define STR 5'b10010 // read Rd
  `define STR2 5'b10011 // add sximm5
  `define STR3 5'b10100 // load to data address dff
  `define STR4 5'b10101 // write to ram
  `define STR5 5'b10110 // new load
  `define STR6 5'b10111 // load instr
  `define readDecode 5'b11000
  `define HALT 5'b11001 

  reg [1:0] reg_selector, wb_selector;
  assign reg_sel = reg_selector;
  assign wb_sel = wb_selector;

  reg wait_out, w_enable, enable_A, enable_B, enable_C, enable_status, select_A, select_B;
  assign waiting = wait_out;
  assign w_en = w_enable;
  assign en_A = enable_A;
  assign en_B = enable_B;
  assign en_C = enable_C;
  assign en_status = enable_status;
  assign sel_A = select_A;
  assign sel_B = select_B;

  // assign new outputs for lab 7
  reg ram_w_enable, load_instr, loadPC, load_address, select_address, clearPC;
  assign ram_w_en = ram_w_enable;
  assign load_ir = load_instr;
  assign load_pc = loadPC;
  assign load_addr = load_address;
  assign sel_addr = select_address;
  assign clear_pc = clearPC;

  reg [4:0] currState;
  assign present_state = currState;
  
  always @(posedge clk) begin
    if (~rst_n) begin
      currState <= `wait;
    end else begin
      case(currState) 
        `wait: begin
          currState <= `fetch1;
        end 
        `fetch1: begin
          currState <= `fetch2;
        end
        `fetch2: begin
          currState <= `decode;
        end
        `decode: begin
          if ({opcode, ALU_op} == 5'b11010) begin
            currState <= `movImmediate;
          end else if ({opcode, ALU_op} == 5'b11000) begin // mov shift
            currState <= `readDecode;
          end else if ({opcode, ALU_op} == 5'b10111) begin // mvn
            currState <= `readDecode;
          end else if ({opcode, ALU_op} == 5'b10100) begin // add
            currState <= `readDecode;
          end else if ({opcode, ALU_op} == 5'b10101) begin // cmp
            currState <= `readDecode;
          end else if ({opcode, ALU_op} == 5'b10110) begin // and
            currState <= `readDecode;
          end else if ({opcode, ALU_op} == 5'b11100) begin // halt
            currState <= `HALT;
          end else if ({opcode, ALU_op} == 5'b01100) begin // ldr
            currState <= `LDR;
          end else if ({opcode, ALU_op} == 5'b10000) begin // str
            currState <= `STR;
          end else begin
            currState <= `wait; // invalid opcode
          end
        end
        `HALT: begin
          currState <= `HALT; // stuck until ~rst_n again
        end
        `movImmediate: begin
          currState <= `fetch1;
        end
        `readDecode: begin
          if ({opcode, ALU_op} == 5'b11000) begin // mov shift
            currState <= `loadB;
          end else if ({opcode, ALU_op} == 5'b10111) begin // mvn
            currState <= `loadB;
          end else if ({opcode, ALU_op} == 5'b10100) begin // add
            currState <= `loadA;
          end else if ({opcode, ALU_op} == 5'b10101) begin // cmp
            currState <= `loadA;
          end else if ({opcode, ALU_op} == 5'b10110) begin // and
            currState <= `loadA;
          end else begin
            currState <= `wait; // invalid opcode
          end
        end
        `loadA: begin
          if ({opcode, ALU_op} == 5'b10100) begin // add
            currState <= `add;
          end else if ({opcode, ALU_op} == 5'b10101) begin // cmp
            currState <= `cmp;
          end else if ({opcode, ALU_op} == 5'b10110) begin // and
            currState <= `and;
          end else begin
            currState <= `wait;
          end
        end
        `loadB: begin
            currState <= `mvn;
        end
        `add: begin
            currState <= `register; 
        end
        `cmp: begin
          currState <= `fetch2; 
        end
        `and: begin
          currState <= `register;
        end
        `mvn: begin
          currState <= `register;
        end
        `register: begin
          currState <= `decode;
        end
        `LDR: begin
          currState <= `LDR2;
        end
        `LDR2: begin
          currState <= `LDR3;
        end
        `LDR3: begin
          currState <= `LDR4;
        end
        `LDR4: begin
          currState <= `LDR5;
        end
        `LDR5: begin
          currState <= `LDR6;
        end
        `LDR6: begin
          currState <= `decode;
        end
        `STR: begin
          currState <= `STR2;
        end
        `STR2: begin
          currState <= `STR3;
        end
        `STR3: begin
          currState <= `STR4;
        end
        `STR4: begin
          currState <= `STR5;
        end
        `STR5: begin
          currState <= `STR6;
        end
        `STR6: begin
          currState <= `decode;
        end
        default: begin
          currState <= `wait;  
        end
      endcase
    end
  end

  always @(*) begin
    case(currState)
    `wait: begin
      reg_selector = 2'b10; // write to Rn
      wb_selector = 2'b10; // sximm8 as input
      wait_out = 1'b1;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b1;
      loadPC = 1'b1;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `decode: begin
      reg_selector = 2'b00; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `loadA: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b1;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b1;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `loadB: begin
      reg_selector = 2'b00; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b1;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b1;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `movImmediate: begin
      reg_selector = 2'b10; // write to Rn
      wb_selector = 2'b10; // sximm8 as input
      wait_out = 1'b0;
      w_enable = 1'b1;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b1;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `add: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0; 
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1; 
    end
    `cmp: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b1; // only update status with compare
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `and: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0; 
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1; 
    end
    `mvn: begin
      reg_selector = 2'b00; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b1;
      select_B = 1'b0;  
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `register: begin
      reg_selector = 2'b01; // write to Rd
      wb_selector = 2'b00; // datapath_output as input
      wait_out = 1'b0;
      w_enable = 1'b1;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0; 
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b1;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    // new state outputs
    `fetch1: begin
      reg_selector = 2'b10; // write to Rn
      wb_selector = 2'b10; // sximm8 as input
      wait_out = 1'b1;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `fetch2: begin
      reg_selector = 2'b10; // write to Rn
      wb_selector = 2'b10; // sximm8 as input
      wait_out = 1'b1;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b1;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `readDecode: begin
      reg_selector = 2'b00; 
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b1;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `LDR: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b10;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b1;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `LDR2: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b10;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b1;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `LDR3: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b10;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b1;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b1;
      select_address = 1'b1;
    end
    `LDR4: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b10;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b0;
    end
    `LDR5: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b1;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `LDR6: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b1;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `STR: begin
      reg_selector = 2'b10; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b1;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `STR2: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b1;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b1;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `STR3: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b1;
      enable_status = 1'b0;
      select_A = 1'b1;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b1;
      select_address = 1'b1;
    end
    `STR4: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b1;
      ram_w_enable = 1'b1;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b0;
    end
    `STR5: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `STR6: begin
      reg_selector = 2'b01; 
      wb_selector = 2'b11;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b1;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    `HALT: begin
      reg_selector = 2'b11; // don't care
      wb_selector = 2'b00;
      wait_out = 1'b0;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0; 
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    default: begin
      reg_selector = 2'b11; 
      wb_selector = 2'b00; 
      wait_out = 1'b1;
      w_enable = 1'b0;
      enable_A = 1'b0;
      enable_B = 1'b0;
      enable_C = 1'b0;
      enable_status = 1'b0;
      select_A = 1'b0;
      select_B = 1'b0;
      // new
      clearPC = 1'b0;
      loadPC = 1'b0;
      ram_w_enable = 1'b0;
      load_instr = 1'b0;
      load_address = 1'b0;
      select_address = 1'b1;
    end
    endcase
  end
     
endmodule: controller

module idecoder(input [15:0] ir, input [1:0] reg_sel,
                output [2:0] opcode, output [1:0] ALU_op, output [1:0] shift_op,
		output [15:0] sximm5, output [15:0] sximm8,
                output [2:0] r_addr, output [2:0] w_addr);

  reg [15:0] sximm5_out, sximm8_out;
  reg [2:0] opcode_out, read_out, write_out;
  reg [1:0] ALU_out, shift_out;

  assign sximm5 = sximm5_out;
  assign sximm8 = sximm8_out;
  assign opcode = opcode_out;
  assign r_addr = read_out;
  assign w_addr = write_out;
  assign ALU_op = ALU_out;
  assign shift_op = shift_out;

  wire [2:0] Rm = ir[2:0];
  wire [2:0] Rd = ir[7:5];
  wire [2:0] Rn = ir[10:8];
  wire [7:0] imm8 = ir[7:0];
  wire [4:0] imm5 = ir[4:0];

  assign shift_out = ir[4:3];
  assign sximm5_out = {{11{imm5[4]}}, imm5[4:0]};
  assign sximm8_out = {{8{imm8[7]}}, imm8[7:0]};
  assign ALU_out = ir[12:11];
  assign opcode_out = ir[15:13];

  vMux3Bit MUXOUT(Rn, Rd, Rm, reg_sel, write_out);
  
  assign read_out = write_out;

endmodule: idecoder

// 3-Bit Multiplexer module 
module vMux3Bit(a2, a1, a0, select, out);

  input [2:0] a2, a1, a0;
  input [1:0] select;
  output [2:0] out;

  reg [2:0] outMux;

  always @(*) begin
    case(select)
      0: outMux = a0;
      1: outMux = a1;
      2: outMux = a2;
      default: outMux = {3{1'bx}}; // don't care
    endcase
  end

  assign out = outMux;

endmodule: vMux3Bit

module datapath(input clk, input [15:0] mdata, input [7:0] pc, input [1:0] wb_sel,
                input [2:0] w_addr, input w_en, input [2:0] r_addr, input en_A,
                input en_B, input [1:0] shift_op, input sel_A, input sel_B,
                input [1:0] ALU_op, input en_C, input en_status,
		input [15:0] sximm8, input [15:0] sximm5,
                output [15:0] datapath_out, output Z_out, output N_out, output V_out);
  // initialize zeros for different sizes
  `define ZERO16 16'b0000000000000000
  `define ZERO8 8'b00000000

  // defines outputs as reg
  reg [15:0] datapath_output;
  assign datapath_out = datapath_output;

  // wires for the outputs of muxes and registers 
  wire [15:0] w_data, r_data;
  wire [15:0] A_in, B_in, shift_out, val_A, val_B, ALU_out;

  // lab 6 additions
  wire [15:0] zero_pc = {`ZERO8, pc};

  wire Z_in, N_in, V_in;
  reg Z, N, V;

  assign Z_out = Z;
  assign N_out = N;
  assign V_out = V;

  // registers 
  vDFF #(16) A(clk, en_A, r_data, A_in);
  vDFF #(16) B(clk, en_B, r_data, B_in);
  vDFF #(16) C(clk, en_C, ALU_out, datapath_output);

  vDFF #(1) ZSTATUS(clk, en_status, Z_in, Z); 
  vDFF #(1) NSTATUS(clk, en_status, N_in, N); 
  vDFF #(1) VSTATUS(clk, en_status, V_in, V); 

  // finds input data
  vMux4Bit INPUT(mdata, sximm8, zero_pc, datapath_output, wb_sel, w_data);

  // finds output data
  regfile RF(.w_data(w_data), .w_addr(w_addr), .w_en(w_en), .r_addr(r_addr), .clk(clk), .r_data(r_data));

  // applies shift operations
  shifter SHIFT(.shift_in(B_in), .shift_op(shift_op), .shift_out(shift_out));

  // finds the value of A and B
  vMux2Bit MUXA(`ZERO16, A_in, sel_A, val_A);
  vMux2Bit MUXB(sximm5, shift_out, sel_B, val_B);

  // finds the datapath output and status "ZNV"
  ALU ALU(.val_A(val_A), .val_B(val_B), .ALU_op(ALU_op), .ALU_out(ALU_out), .Z(Z_in), .N(N_in), .V(V_in));

endmodule: datapath

// d flip-flop module with enable to load
module vDFF(clk, en, in, out);
  parameter n;

  input clk, en;
  input [n-1:0] in;
  output [n-1:0] out;

  reg [n-1:0] tempOut;
  assign out = tempOut;
  wire [n-1:0] selector;

  assign selector = en ? in : tempOut;
  
  always @(posedge clk) begin
    tempOut <= selector; 
  end

endmodule: vDFF

// 2-Bit Multiplexer module 
module vMux2Bit(a1, a0, select, out);

  input [15:0] a1, a0;
  input select;
  output [15:0] out;

  reg [15:0] outMux;

  always @(*) begin
    case(select)
      0: outMux = a0;
      1: outMux = a1;
    endcase
  end

  assign out = outMux;

endmodule: vMux2Bit

// 4-Bit Multiplexer module 
module vMux4Bit(a3, a2, a1, a0, select, out);

  input [15:0] a3, a2, a1, a0;
  input [1:0] select;
  output [15:0] out;

  reg [15:0] outMux;

  always @(*) begin
    case(select)
      0: outMux = a0;
      1: outMux = a1;
      2: outMux = a2;
      3: outMux = a3; 
    endcase
  end

  assign out = outMux;

endmodule: vMux4Bit

module ALU(input [15:0] val_A, input [15:0] val_B, input [1:0] ALU_op, output [15:0] ALU_out, output Z, output N, output V);
  // define variables
  `define ZERO16 16'b0000000000000000
  `define ZERO 2'b00
  `define ONE 2'b01
  `define TWO 2'b10
  `define THREE 2'b11

  // define outputs as reg
  reg [15:0] ALU_output;
  assign ALU_out = ALU_output;

  reg Z_out, N_out, V_out;
  assign Z = Z_out;
  assign N = N_out;
  assign V = V_out;

  // combinational logic for ALU operations
  always @(*) begin
    case(ALU_op) 
    `ZERO: ALU_output = val_A + val_B;
    `ONE: ALU_output = val_A - val_B;
    `TWO: ALU_output = val_A & val_B;
    `THREE: ALU_output = ~val_B;
    endcase  
  end

  // combinational logic for status
  always @(*) begin
    
    if (ALU_output == `ZERO16) begin
      Z_out = 1'b1; // set zero
    end else begin
      Z_out = 1'b0;
    end

    if (ALU_output[15] == 1) begin
      N_out = 1'b1; // set negative  
    end else begin
      N_out = 1'b0;
    end

    case({val_A[15], val_B[15], ALU_op, ALU_output[15]})
      5'b00001: V_out = 1'b1;
      5'b11000: V_out = 1'b1;
      5'b01011: V_out = 1'b1;
      5'b10010: V_out = 1'b1;
      default: V_out = 1'b0;
    endcase

  end

endmodule: ALU

module shifter(input [15:0] shift_in, input [1:0] shift_op, output reg [15:0] shift_out);
  // define variables
  `define ZERO 2'b00
  `define ONE 2'b01
  `define TWO 2'b10
  `define THREE 2'b11

  // combinational logic for shift operations
  always @(*) begin
    case(shift_op)
      `ZERO: shift_out = shift_in;
      `ONE: shift_out = shift_in << 1;
      `TWO: shift_out = shift_in >> 1;
      `THREE: begin
          shift_out = shift_in >> 1;
          shift_out[15] = shift_in[15];
      end
    endcase
  end
  
endmodule: 

// equality comparator
module equalitycomp(a, b, eq) ;
  parameter k=8;
  input     [k-1:0] a,b;
  output    eq;
  wire      eq;

  assign eq = (a==b) ;
endmodule


// sseg module (HEX Display)
module sseg(in, segs);
  input [5:0]       in;
  output reg [6:0]  segs;

  always @(*) begin
    case (in)
      6'b000000: segs = 7'b1000000; // 0
      6'b000001: segs = 7'b1111001; // 1
      6'b000010: segs = 7'b0100100; // 2
      6'b000011: segs = 7'b0110000; // 3
      6'b000100: segs = 7'b0011001; // 4
      6'b000101: segs = 7'b0010010; // 5
      6'b000110: segs = 7'b0000010; // 6
      6'b000111: segs = 7'b1111000; // 7
      6'b001000: segs = 7'b0000000; // 8
      6'b001001: segs = 7'b0011000; // 9
      default: segs = 7'b1111111; // No display
    endcase
  end
endmodule